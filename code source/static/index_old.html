<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HGL Curve Prediction Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        body { font-family: 'Roboto', sans-serif; background-color: #f4f7f6; color: #333; margin: 0; padding: 2em; display: flex; flex-direction: column; align-items: center; }
        .container { background-color: white; padding: 2em; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 80%; max-width: 1200px; }
        h1, h2, h3 { color: #2c3e50; text-align: center; }
        .upload-section { display: flex; flex-direction: column; align-items: center; gap: 1.5em; padding: 1.5em; border: 2px dashed #ccc; border-radius: 8px; background-color: #fafafa; }
        .action-buttons { display: flex; gap: 1em; }
        button { background-color: #3498db; color: white; border: none; padding: 12px 25px; font-size: 1.1em; font-weight: bold; border-radius: 5px; cursor: pointer; transition: background-color 0.3s ease; }
        button.secondary { background-color: #2ecc71; }
        button:hover { opacity: 0.9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        hr { border: 0; border-top: 1px solid #eee; margin: 2em 0; }
        .spinner { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 2em auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        table { width: 100%; border-collapse: collapse; margin-top: 1em; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #ecf0f1; }
        .model-choice { display: flex; justify-content: center; gap: 2em; }
        .model-choice label { font-size: 1.1em; }
        .comparison-charts { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 2em; margin-top: 1em; }
        .prediction-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 2em; margin-top: 1em; }
        .single-result-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 2em; align-items: start; }
        .requirements-section { background-color: #e9f5ff; border: 1px solid #b3d7f2; padding: 0.5em 1.5em; border-radius: 8px; margin: 1.5em 0; }
        .template-btn { background-color: #1abc9c; display: inline-block; margin-top: 0.5em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒŠ HGL Curve Prediction Interface</h1>
        <p>Upload your dataset, then choose to either train a single model for a detailed analysis or train all models to compare their performance.</p>
        <div class="requirements-section">
            <h3>Data Requirements</h3>
            <p>Your CSV file must be comma-separated and contain the exact column headers used for training. Click the button below to download a template with all required columns.</p>
            <a href="./template.csv" download="hgl_data_template.csv"><button class="template-btn">Download Template CSV</button></a>
        </div>
        <div class="upload-section">
            <h3>Step 1: Upload Your Formatted Dataset</h3>
            <input type="file" id="csvFileInput" accept=".csv">
            <h3>Step 2: Choose an Action</h3>
            <div class="model-choice">
                <label><input type="radio" name="model" value="LSTM" checked> LSTM</label>
                <label><input type="radio" name="model" value="GRU"> GRU</label>
                <label><input type="radio" name="model" value="TCN"> TCN</label>
            </div>
            <div class="action-buttons">
                <button id="trainButton" onclick="handleTrainSingleClick()">Train Selected Model</button>
                <button id="compareButton" class="secondary" onclick="handleCompareAllClick()">Train & Compare All</button>
            </div>
        </div>
        <hr>
        <div id="resultsSection" class="results-section">
            <p style="text-align: center; color: #777;">Results will be displayed here.</p>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('csvFileInput');
        const trainButton = document.getElementById('trainButton');
        const compareButton = document.getElementById('compareButton');
        const resultsSection = document.getElementById('resultsSection');

        function showLoading(message) {
            trainButton.disabled = true;
            compareButton.disabled = true;
            resultsSection.innerHTML = `<h2>${message}</h2><p>Please wait...</p><div class="spinner"></div>`;
        }

        function enableButtons() {
            trainButton.disabled = false;
            compareButton.disabled = false;
        }

        async function handleTrainSingleClick() {
            if (fileInput.files.length === 0) { alert("Please select a CSV file first!"); return; }
            const selectedModel = document.querySelector('input[name="model"]:checked').value;
            showLoading(`Training ${selectedModel} Model...`);
            const formData = new FormData();
            formData.append("file", fileInput.files[0]);
            formData.append("model_name", selectedModel);
            try {
                // CORRECTED: Added full URL
                const response = await fetch("http://127.0.0.1:8000/train_single_model/", { method: "POST", body: formData });
                if (!response.ok) { throw new Error((await response.json()).detail); }
                const data = await response.json();
                displaySingleModelResults(data);
            } catch (error) {
                resultsSection.innerHTML = `<h2 style="color: red;">An Error Occurred</h2><p>${error.message}</p>`;
            } finally {
                enableButtons();
            }
        }

        async function handleCompareAllClick() {
            if (fileInput.files.length === 0) { alert("Please select a CSV file first!"); return; }
            showLoading("Training all models for comparison...");
            const formData = new FormData();
            formData.append("file", fileInput.files[0]);
            try {
                // CORRECTED: Added full URL
                const response = await fetch("http://127.0.0.1:8000/train_all_models/", { method: "POST", body: formData });
                if (!response.ok) { throw new Error((await response.json()).detail); }
                const data = await response.json();
                displayComparisonResults(data);
            } catch (error) {
                resultsSection.innerHTML = `<h2 style="color: red;">An Error Occurred</h2><p>${error.message}</p>`;
            } finally {
                enableButtons();
            }
        }
        
        // --- This is the new helper function to create the complex chart ---
        function createProfessionalGeographicChart(canvasId, geographic_data, predictions, modelName) {
            const stationNames = ['Head', 'PMS1', 'VANNE', 'PMS2', 'PMS3', 'PMS4', 'Terminal'];
            const stationDistances = geographic_data.station_distances;
            // Find the station points on the true HGL curve for labeling
            const stationMarkers = stationDistances.map((distance, index) => ({
                x: distance,
                y: predictions.true_path.find(p => Math.abs(p.x - distance) < 1)?.y || 0,
            }));

            // Calculate axis limits for better padding
            const allYValues = [ ...geographic_data.ground_profile.map(p => p.y), ...predictions.true_path.map(p => p.y), ...predictions.pred_path.map(p => p.y) ];
            const minY = Math.min(...allYValues);
            const maxY = Math.max(...allYValues);
            const yPadding = (maxY - minY) * 0.15;
            const yMin = Math.max(0, minY - yPadding);
            const yMax = maxY + yPadding;
            
            new Chart(document.getElementById(canvasId), {
                type: 'line',
                data: {
                    datasets: [
                        { label: 'Ground Profile', data: geographic_data.ground_profile, showLine: true, fill: 'origin', backgroundColor: 'rgba(139, 115, 85, 0.6)', borderColor: 'rgb(205, 133, 63)', borderWidth: 2, pointRadius: 0, tension: 0.1, order: 4 },
                        { label: 'True HGL', data: predictions.true_path, borderColor: 'rgb(30, 144, 255)', borderWidth: 3, pointRadius: 0, tension: 0, showLine: true, order: 2 },
                        { label: `Predicted HGL (${modelName})`, data: predictions.pred_path, borderColor: 'rgb(255, 69, 0)', borderDash: [8, 4], borderWidth: 2, pointRadius: 0, tension: 0, showLine: true, order: 1 },
                        { label: 'Stations', data: stationMarkers, backgroundColor: 'rgb(30, 144, 255)', pointStyle: 'triangle', rotation: 0, radius: 8, hoverRadius: 10, showLine: false, order: 0 }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: modelName ? `${modelName} Model: Geographic Profile & HGL` : 'Geographic Profile & HGL', font: { size: 16 } },
                        legend: { position: 'top', labels: { usePointStyle: true } },
                        annotation: {
                            annotations: geographic_data.river_crossings.map((river, i) => ({
                                type: 'box', xMin: river.start_km, xMax: river.end_km, yMin: yMin, yMax: yMax,
                                backgroundColor: 'rgba(135, 206, 235, 0.2)', borderColor: 'rgba(135, 206, 235, 0.4)'
                            }))
                        }
                    },
                    scales: {
                        x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Distance (km)' } },
                        y: { min: yMin, max: yMax, title: { display: true, text: 'Elevation / Head (m)' } }
                    }
                }
            });
        }

        function displaySingleModelResults(data) {
            const { model_name, metrics, predictions, geographic_data } = data;
            resultsSection.innerHTML = `
                <h2>ðŸ“Š Results for ${model_name} Model</h2>
                <div class="single-result-grid">
                    <div class="metrics-column">
                        <h3>Performance Metrics</h3>
                        <table>
                            <tr><th>Metric</th><th>Value</th></tr>
                            <tr><td>MSE</td><td>${metrics.MSE.toFixed(4)}</td></tr>
                            <tr><td>RMSE</td><td>${metrics.RMSE.toFixed(4)}</td></tr>
                            <tr><td>MAE</td><td>${metrics.MAE.toFixed(4)}</td></tr>
                            <tr><td>RÂ² Score</td><td>${metrics.R2.toFixed(4)}</td></tr>
                        </table><br>
                        <canvas id="singleErrorChart"></canvas><br>
                        <canvas id="singleR2Chart"></canvas>
                    </div>
                    <div class="curve-column">
                        <h3>Geographic Profile and HGL Curve</h3>
                        <canvas id="resultChart"></canvas>
                    </div>
                </div>
            `;
            
            createProfessionalGeographicChart('resultChart', geographic_data, predictions, model_name);

            const { MSE, RMSE, MAE, R2 } = metrics;
            // CORRECTED: Removed extra curly braces
            new Chart(document.getElementById('singleErrorChart'), { type: 'bar', data: { labels: ['MSE', 'RMSE', 'MAE'], datasets: [{ label: 'Error Value (Log Scale)', data: [MSE, RMSE, MAE], backgroundColor: [ 'rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)' ] }] }, options: { plugins: { title: { display: true, text: 'Error Metrics' } }, scales: { y: { type: 'logarithmic', title: { display: true, text: 'Value' } } } } });
            new Chart(document.getElementById('singleR2Chart'), { type: 'bar', data: { labels: ['RÂ² Score'], datasets: [{ label: 'RÂ² Score (Higher is Better)', data: [R2], backgroundColor: ['rgba(75, 192, 192, 0.5)'] }] }, options: { plugins: { title: { display: true, text: 'Coefficient of Determination' } }, scales: { y: { min: 0, max: 1, title: { display: true, text: 'Value' } } } } });
        }
        
        function displayComparisonResults(data) {
            const { metrics, predictions, geographic_data } = data;
            resultsSection.innerHTML = `
                <h2>ðŸ“Š Model Performance Comparison</h2>
                <div class="comparison-charts">
                    <div><h3>Error Metrics (MSE, RMSE, MAE)</h3><canvas id="errorChart"></canvas></div>
                    <div><h3>RÂ² Score (Higher is Better)</h3><canvas id="r2Chart"></canvas></div>
                </div><hr>
                <h2>ðŸ“ˆ Geographic Profile and Curve Predictions</h2>
                <div id="predictionCharts" class="prediction-grid"></div>
            `;
            
            const modelNames = Object.keys(metrics);
            const mseValues = modelNames.map(m => metrics[m].MSE); 
            const rmseValues = modelNames.map(m => metrics[m].RMSE); 
            const maeValues = modelNames.map(m => metrics[m].MAE); 
            const r2Values = modelNames.map(m => metrics[m].R2);
            
            // CORRECTED: Removed extra curly braces
            new Chart(document.getElementById('errorChart'), { type: 'bar', data: { labels: modelNames, datasets: [ { label: 'MSE', data: mseValues, backgroundColor: 'rgba(255, 99, 132, 0.5)' }, { label: 'RMSE', data: rmseValues, backgroundColor: 'rgba(54, 162, 235, 0.5)' }, { label: 'MAE', data: maeValues, backgroundColor: 'rgba(255, 206, 86, 0.5)' } ] }, options: { scales: { y: { type: 'logarithmic', beginAtZero: true, title: { display: true, text: 'Error Value (Log Scale)' } } } } });
            new Chart(document.getElementById('r2Chart'), { type: 'bar', data: { labels: modelNames, datasets: [ { label: 'RÂ² Score', data: r2Values, backgroundColor: 'rgba(75, 192, 192, 0.5)' } ] }, options: { indexAxis: 'y', scales: { x: { beginAtZero: true, title: { display: true, text: 'RÂ² Score' } } } } });

            const predictionChartsContainer = document.getElementById('predictionCharts');
            for (const modelName of modelNames) {
                const chartContainer = document.createElement('div');
                const chartId = `prediction-chart-${modelName}`;
                chartContainer.innerHTML = `<canvas id="${chartId}"></canvas>`;
                predictionChartsContainer.appendChild(chartContainer);
                
                createProfessionalGeographicChart(chartId, geographic_data, predictions[modelName], modelName);
            }
        }
    </script>
</body>
</html>